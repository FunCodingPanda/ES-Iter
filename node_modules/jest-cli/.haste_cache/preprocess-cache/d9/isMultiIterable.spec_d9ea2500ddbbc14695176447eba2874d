'use strict'; // istanbul ignore next
function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}require('../auto_mock_off');require('babel/polyfill');var _srcItertools = require(
'../src/itertools');

describe('isMultiIterable', function () {
    var obj = _defineProperty({}, 
    Symbol.iterator, function () {
        return _defineProperty({ 
            next: function next() {
                return { value: true, done: false };} }, 

        Symbol.iterator, function () {
            return this;});});





    it('obj[Symbol.iterator]() returns fresh iterator on every call', function () {var _iteratorNormalCompletion = true;var _didIteratorError = false;var _iteratorError = undefined;try {
            for (var _iterator = obj[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {var x = _step.value;}} catch (err) {_didIteratorError = true;_iteratorError = err;} finally {try {if (!_iteratorNormalCompletion && _iterator['return']) {_iterator['return']();}} finally {if (_didIteratorError) {throw _iteratorError;}}}var _iteratorNormalCompletion2 = true;var _didIteratorError2 = false;var _iteratorError2 = undefined;try {
            for (var _iterator2 = obj[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {var y = _step2.value;}} catch (err) {_didIteratorError2 = true;_iteratorError2 = err;} finally {try {if (!_iteratorNormalCompletion2 && _iterator2['return']) {_iterator2['return']();}} finally {if (_didIteratorError2) {throw _iteratorError2;}}}
        expect((0, _srcItertools.isMultiIterable)(obj)).toBe(true);
        expect(x).toBe(true);
        expect(y).toBe(true);});});