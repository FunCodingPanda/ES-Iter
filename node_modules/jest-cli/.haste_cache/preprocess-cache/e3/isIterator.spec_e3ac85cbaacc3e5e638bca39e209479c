'use strict'; // istanbul ignore next
function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}require('./auto_mock_off');require('babel/polyfill');var _srcItertools = require(
'../src/itertools');

describe('isIterator', function () {
    it('returns true with iterators', function () {
        var iter = _defineProperty({ 
            next: function next() {} }, 
        Symbol.iterator, function () {return this;});


        expect((0, _srcItertools.isIterator)(iter)).toBe(true);
        expect((0, _srcItertools.isIterator)([][Symbol.iterator]())).toBe(true);
        expect((0, _srcItertools.isIterator)(''[Symbol.iterator]())).toBe(true);
        expect((0, _srcItertools.isIterator)(new Map()[Symbol.iterator]())).toBe(true);
        expect((0, _srcItertools.isIterator)(new Set()[Symbol.iterator]())).toBe(true);});


    it('returns false with object which not implements properly Iterator protocol', function () {
        var iter = _defineProperty({}, Symbol.iterator, function () {return this;});
        expect((0, _srcItertools.isIterator)(iter)).toBe(false);});


    it('returns false with non iterables', function () {
        expect((0, _srcItertools.isIterator)(Object.create(null))).toBe(false);
        expect((0, _srcItertools.isIterator)(546)).toBe(false);});


    it('returns false with iterable non iterators', function () {
        expect((0, _srcItertools.isIterator)([])).toBe(false);
        expect((0, _srcItertools.isIterator)('')).toBe(false);
        expect((0, _srcItertools.isIterator)(new Map())).toBe(false);
        expect((0, _srcItertools.isIterator)(new Set())).toBe(false);});


    it('returns false without arguments or null', function () {
        expect((0, _srcItertools.isIterator)()).toBe(false);
        expect((0, _srcItertools.isIterator)(null)).toBe(false);});});