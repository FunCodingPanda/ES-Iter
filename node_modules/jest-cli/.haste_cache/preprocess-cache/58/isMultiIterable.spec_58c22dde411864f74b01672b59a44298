'use strict'; // istanbul ignore next
function _toConsumableArray(arr) {if (Array.isArray(arr)) {for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];return arr2;} else {return Array.from(arr);}} // istanbul ignore next
function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}require('./auto_mock_off');require('babel/polyfill');var _srcItertools = require('../src/itertools');

describe('isMultiIterable', function () {
    var obj = _defineProperty({}, 
    Symbol.iterator, function () {
        return _defineProperty({ 
            next: function next() {
                if (!this._counter) {
                    this._counter = true;
                    return { value: true, done: false };} else 

                {
                    return { done: true };}} }, 


        Symbol.iterator, function () {
            return this;});});





    it('returns true if obj[Symbol.iterator]() returns fresh iterator on every call', function () {
        var x = [].concat(_toConsumableArray(obj))[0], 
        y = [].concat(_toConsumableArray(obj))[0];
        expect((0, _srcItertools.isMultiIterable)(obj)).toBe(true);
        expect(x).toBe(true);
        expect(y).toBe(true);});


    it('returns false if obj[Symbol.iterator]() returns same object every time', function () {
        var iter = obj[Symbol.iterator](), 
        x = [].concat(_toConsumableArray(iter))[0], 
        y = [].concat(_toConsumableArray(iter))[0];

        expect((0, _srcItertools.isMultiIterable)(iter)).toBe(false);
        expect(x).toBe(true);
        expect(y).toBe(undefined);});


    it('returns false with not iterable object', function () {
        expect((0, _srcItertools.isMultiIterable)(Object.create(null))).toBe(false);});


    it('returns false with no arguments', function () {
        expect((0, _srcItertools.isMultiIterable)()).toBe(false);});});