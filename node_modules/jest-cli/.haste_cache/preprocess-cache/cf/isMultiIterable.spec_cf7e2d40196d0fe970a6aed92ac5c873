'use strict'; // istanbul ignore next
function _defineProperty(obj, key, value) {if (key in obj) {Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });} else {obj[key] = value;}return obj;}require('../auto_mock_off');require('babel/polyfill');var _srcItertools = require(
'../src/itertools');

describe('isMultiIterable', function () {
    var obj = _defineProperty({}, 
    Symbol.iterator, function () {
        return _defineProperty({ 
            next: function next() {
                if (!this._counter) {
                    this._counter = true;
                    return { value: true, done: false };} else 

                {
                    return { done: true };}} }, 


        Symbol.iterator, function () {
            return this;});});





    it('Returns true if obj[Symbol.iterator]() returns fresh iterator on every call', function () {var _iteratorNormalCompletion = true;var _didIteratorError = false;var _iteratorError = undefined;try {
            for (var _iterator = obj[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {var x = _step.value;}} catch (err) {_didIteratorError = true;_iteratorError = err;} finally {try {if (!_iteratorNormalCompletion && _iterator['return']) {_iterator['return']();}} finally {if (_didIteratorError) {throw _iteratorError;}}}var _iteratorNormalCompletion2 = true;var _didIteratorError2 = false;var _iteratorError2 = undefined;try {
            for (var _iterator2 = obj[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {var y = _step2.value;}} catch (err) {_didIteratorError2 = true;_iteratorError2 = err;} finally {try {if (!_iteratorNormalCompletion2 && _iterator2['return']) {_iterator2['return']();}} finally {if (_didIteratorError2) {throw _iteratorError2;}}}
        expect((0, _srcItertools.isMultiIterable)(obj)).toBe(true);
        expect(x).toBe(true);
        expect(y).toBe(true);});


    it('Returns false if obj[Symbol.iterator]() returns same object every time', function () {
        var iter = obj[Symbol.iterator]();var _iteratorNormalCompletion3 = true;var _didIteratorError3 = false;var _iteratorError3 = undefined;try {
            for (var _iterator3 = iter[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {var x = _step3.value;}} catch (err) {_didIteratorError3 = true;_iteratorError3 = err;} finally {try {if (!_iteratorNormalCompletion3 && _iterator3['return']) {_iterator3['return']();}} finally {if (_didIteratorError3) {throw _iteratorError3;}}}var _iteratorNormalCompletion4 = true;var _didIteratorError4 = false;var _iteratorError4 = undefined;try {
            for (var _iterator4 = iter[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {var y = _step4.value;}} catch (err) {_didIteratorError4 = true;_iteratorError4 = err;} finally {try {if (!_iteratorNormalCompletion4 && _iterator4['return']) {_iterator4['return']();}} finally {if (_didIteratorError4) {throw _iteratorError4;}}}
        expect((0, _srcItertools.isMultiIterable)(iter)).toBe(false);
        expect(x).toBe(true);
        expect(y).toBe(undefined);});


    it('Returns false if object is not iterable', function () {
        expect((0, _srcItertools.isMultiIterable)(Object.create(null))).toBe(false);});


    it('Returns false with no arguments', function () {
        expect((0, _srcItertools.isMultiIterable)()).toBe(false);});});